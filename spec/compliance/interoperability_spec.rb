# frozen_string_literal: true

##
# Interoperability Test Suite
#
# This test suite validates interoperability between the Ruby A2A implementation
# and other A2A SDK implementations, particularly the Python SDK.
#
RSpec.describe "A2A Interoperability", :compliance, :interoperability do
  describe "Message Format Interoperability" do
    context "with Python SDK message formats" do
      it "parses messages generated by Python SDK" do
        # Message format as generated by a2a-python
        python_message = {
          "messageId" => "550e8400-e29b-41d4-a716-446655440000",
          "role" => "user",
          "kind" => "message",
          "parts" => [
            {
              "kind" => "text",
              "text" => "Hello from Python SDK"
            }
          ],
          "contextId" => "550e8400-e29b-41d4-a716-446655440001",
          "taskId" => "550e8400-e29b-41d4-a716-446655440002",
          "metadata" => {
            "timestamp" => "2024-01-01T12:00:00Z",
            "source" => "python-sdk"
          }
        }

        expect(python_message).to be_valid_a2a_message
      end

      it "generates messages compatible with Python SDK" do
        ruby_message = build_message(
          role: "agent",
          text: "Hello from Ruby SDK"
        )

        # Convert to the format expected by Python SDK (camelCase)
        python_compatible = {
          "messageId" => ruby_message[:messageId],
          "role" => ruby_message[:role],
          "kind" => ruby_message[:kind],
          "parts" => ruby_message[:parts]
        }

        expect(python_compatible).to be_valid_a2a_message
      end

      it "handles file parts with both bytes and URI formats" do
        # Python SDK file with bytes (base64 encoded)
        python_file_message = {
          "messageId" => test_uuid,
          "role" => "user",
          "kind" => "message",
          "parts" => [
            {
              "kind" => "file",
              "file" => {
                "name" => "test.txt",
                "mimeType" => "text/plain",
                "bytes" => Base64.encode64("Hello from Python")
              }
            }
          ]
        }

        expect(python_file_message).to be_valid_a2a_message

        # Python SDK file with URI
        python_uri_message = {
          "messageId" => test_uuid,
          "role" => "user",
          "kind" => "message",
          "parts" => [
            {
              "kind" => "file",
              "file" => {
                "name" => "remote.txt",
                "mimeType" => "text/plain",
                "uri" => "https://example.com/files/remote.txt"
              }
            }
          ]
        }

        expect(python_uri_message).to be_valid_a2a_message
      end

      it "handles complex nested data parts" do
        python_data_message = {
          "messageId" => test_uuid,
          "role" => "user",
          "kind" => "message",
          "parts" => [
            {
              "kind" => "data",
              "data" => {
                "analysisRequest" => {
                  "type" => "sentiment",
                  "parameters" => {
                    "language" => "en",
                    "confidence_threshold" => 0.8
                  },
                  "options" => {
                    "include_entities" => true,
                    "return_probabilities" => false
                  }
                }
              }
            }
          ]
        }

        expect(python_data_message).to be_valid_a2a_message
      end
    end
  end

  describe "Task Format Interoperability" do
    context "with Python SDK task formats" do
      it "parses tasks generated by Python SDK" do
        python_task = {
          "id" => test_uuid,
          "contextId" => test_uuid,
          "kind" => "task",
          "status" => {
            "state" => "working",
            "message" => "Processing request",
            "progress" => 50,
            "updatedAt" => "2024-01-01T12:00:00Z"
          },
          "artifacts" => [
            {
              "artifactId" => test_uuid,
              "name" => "Intermediate Results",
              "parts" => [
                {
                  "kind" => "text",
                  "text" => "Processing 50% complete"
                }
              ]
            }
          ],
          "metadata" => {
            "createdBy" => "python-sdk",
            "priority" => "normal"
          }
        }

        expect(python_task).to be_valid_a2a_task
      end

      it "generates tasks compatible with Python SDK" do
        ruby_task = build_task(
          state: "completed",
          artifacts: [
            {
              artifactId: test_uuid,
              name: "Ruby Results",
              parts: [{ kind: "text", text: "Completed by Ruby SDK" }]
            }
          ]
        )

        # Convert to Python SDK format
        python_compatible = {
          "id" => ruby_task[:id],
          "contextId" => ruby_task[:contextId],
          "kind" => ruby_task[:kind],
          "status" => ruby_task[:status],
          "artifacts" => ruby_task[:artifacts]
        }

        expect(python_compatible).to be_valid_a2a_task
      end

      it "handles all task states consistently" do
        task_states = %w[
          submitted working input-required completed
          canceled failed rejected auth-required unknown
        ]

        task_states.each do |state|
          python_task = {
            "id" => test_uuid,
            "contextId" => test_uuid,
            "kind" => "task",
            "status" => {
              "state" => state,
              "updatedAt" => Time.now.utc.iso8601
            }
          }

          expect(python_task).to be_valid_a2a_task
          expect(state).to be_valid_task_state
        end
      end
    end
  end

  describe "Agent Card Interoperability" do
    context "with Python SDK agent cards" do
      it "parses agent cards generated by Python SDK" do
        python_agent_card = {
          "name" => "Python Test Agent",
          "description" => "An agent implemented with the Python SDK",
          "version" => "1.0.0",
          "url" => "https://python-agent.example.com/a2a",
          "preferredTransport" => "JSONRPC",
          "protocolVersion" => "0.3.0",
          "skills" => [
            {
              "id" => "python_skill",
              "name" => "Python Processing",
              "description" => "Process data using Python",
              "tags" => %w[python processing],
              "examples" => ["Process this data", "Analyze with Python"]
            }
          ],
          "capabilities" => {
            "streaming" => true,
            "pushNotifications" => true,
            "stateTransitionHistory" => false
          },
          "defaultInputModes" => ["text/plain", "application/json"],
          "defaultOutputModes" => ["application/json", "text/plain"],
          "additionalInterfaces" => [
            {
              "transport" => "GRPC",
              "url" => "grpc://python-agent.example.com:443"
            }
          ],
          "securitySchemes" => {
            "oauth2" => {
              "type" => "oauth2",
              "flows" => {
                "clientCredentials" => {
                  "tokenUrl" => "https://auth.example.com/token",
                  "scopes" => {
                    "read" => "Read access",
                    "write" => "Write access"
                  }
                }
              }
            }
          },
          "security" => [
            { "oauth2" => %w[read write] }
          ]
        }

        expect(python_agent_card).to be_valid_agent_card
      end

      it "generates agent cards compatible with Python SDK" do
        ruby_card = generate_full_agent_card(
          name: "Ruby Test Agent",
          description: "An agent implemented with the Ruby SDK"
        )

        # Ensure compatibility with Python SDK expectations
        expect(ruby_card).to be_valid_agent_card
        expect(ruby_card[:preferredTransport]).to be_valid_transport

        # Check that all required fields are present
        required_fields = %w[
          name description version url preferredTransport
          skills capabilities defaultInputModes defaultOutputModes
        ]

        required_fields.each do |field|
          expect(ruby_card).to have_key(field.to_sym)
        end
      end
    end
  end

  describe "JSON-RPC Interoperability" do
    context "with Python SDK JSON-RPC format" do
      it "parses JSON-RPC requests from Python SDK" do
        python_request = {
          "jsonrpc" => "2.0",
          "method" => "message/send",
          "params" => {
            "message" => {
              "messageId" => test_uuid,
              "role" => "user",
              "kind" => "message",
              "parts" => [
                { "kind" => "text", "text" => "Hello from Python" }
              ]
            },
            "streaming" => false
          },
          "id" => 1
        }

        expect(python_request).to be_valid_json_rpc_request

        # Parse using Ruby implementation
        parsed = A2A::Protocol::JsonRpc.parse_request(python_request.to_json)
        expect(parsed.method).to eq("message/send")
        expect(parsed.params["message"]).to be_valid_a2a_message
      end

      it "generates JSON-RPC responses compatible with Python SDK" do
        ruby_response = A2A::Protocol::JsonRpc.build_response(
          result: {
            "messageId" => test_uuid,
            "role" => "agent",
            "kind" => "message",
            "parts" => [
              { "kind" => "text", "text" => "Hello from Ruby" }
            ]
          },
          id: 1
        )

        expect(ruby_response).to be_valid_json_rpc_response
        expect(ruby_response[:result]).to be_valid_a2a_message
      end

      it "handles batch requests consistently" do
        python_batch = [
          {
            "jsonrpc" => "2.0",
            "method" => "message/send",
            "params" => { "message" => build_message },
            "id" => 1
          },
          {
            "jsonrpc" => "2.0",
            "method" => "tasks/get",
            "params" => { "id" => test_uuid },
            "id" => 2
          }
        ]

        parsed_batch = A2A::Protocol::JsonRpc.parse_request(python_batch.to_json)
        expect(parsed_batch).to be_an(Array)
        expect(parsed_batch.length).to eq(2)

        parsed_batch.each { |req| expect(req).to be_a(A2A::Protocol::Request) }
      end

      it "uses consistent error codes" do
        # Error codes should match between implementations
        error_mappings = {
          A2A::Protocol::JsonRpc::PARSE_ERROR => -32_700,
          A2A::Protocol::JsonRpc::INVALID_REQUEST => -32_600,
          A2A::Protocol::JsonRpc::METHOD_NOT_FOUND => -32_601,
          A2A::Protocol::JsonRpc::INVALID_PARAMS => -32_602,
          A2A::Protocol::JsonRpc::INTERNAL_ERROR => -32_603,
          A2A::Protocol::JsonRpc::TASK_NOT_FOUND => -32_001,
          A2A::Protocol::JsonRpc::TASK_NOT_CANCELABLE => -32_002,
          A2A::Protocol::JsonRpc::AUTHENTICATION_REQUIRED => -32_004
        }

        error_mappings.each do |constant, expected_code|
          expect(constant).to eq(expected_code)
        end
      end
    end
  end

  describe "Event Format Interoperability" do
    context "with Python SDK event formats" do
      it "parses task status update events from Python SDK" do
        python_event = {
          "taskId" => test_uuid,
          "contextId" => test_uuid,
          "status" => {
            "state" => "working",
            "message" => "Processing with Python SDK",
            "progress" => 75,
            "updatedAt" => Time.now.utc.iso8601
          },
          "metadata" => {
            "source" => "python-sdk",
            "version" => "1.0.0"
          }
        }

        expect(python_event).to be_valid_task_status_update_event
      end

      it "parses task artifact update events from Python SDK" do
        python_artifact_event = {
          "taskId" => test_uuid,
          "contextId" => test_uuid,
          "artifact" => {
            "artifactId" => test_uuid,
            "name" => "Python Generated Artifact",
            "description" => "Generated by Python SDK",
            "parts" => [
              {
                "kind" => "data",
                "data" => {
                  "results" => %w[item1 item2 item3],
                  "metadata" => { "count" => 3 }
                }
              }
            ]
          },
          "append" => false,
          "metadata" => {
            "generatedBy" => "python-sdk"
          }
        }

        expect(python_artifact_event).to be_valid_task_artifact_update_event
      end

      it "generates events compatible with Python SDK" do
        ruby_status_event = build_task_status_update(
          task_id: test_uuid,
          context_id: test_uuid,
          state: "completed"
        )

        # Convert to format expected by Python SDK
        python_compatible = {
          "taskId" => ruby_status_event[:taskId],
          "contextId" => ruby_status_event[:contextId],
          "status" => ruby_status_event[:status]
        }

        expect(python_compatible).to be_valid_task_status_update_event
      end
    end
  end

  describe "Server-Sent Events Interoperability" do
    context "with Python SDK SSE format" do
      it "parses SSE events from Python SDK" do
        python_sse_events = [
          "data: {\"taskId\":\"#{test_uuid}\",\"status\":{\"state\":\"working\"}}\n\n",
          "event: task_status_update\ndata: {\"taskId\":\"#{test_uuid}\",\"status\":{\"state\":\"completed\"}}\n\n",
          "id: event-123\nevent: task_artifact_update\ndata: {\"taskId\":\"#{test_uuid}\",\"artifact\":{\"artifactId\":\"#{test_uuid}\",\"parts\":[]}}\n\n"
        ]

        python_sse_events.each do |sse_event|
          expect(sse_event).to be_valid_sse_event

          parsed = parse_sse_event(sse_event)
          expect(parsed).to have_key(:data)
        end
      end

      it "generates SSE events compatible with Python SDK" do
        ruby_event_data = build_task_status_update(
          task_id: test_uuid,
          context_id: test_uuid,
          state: "working"
        )

        sse_event = format_sse_event(
          ruby_event_data,
          event_type: "task_status_update",
          id: "ruby-event-1"
        )

        expect(sse_event).to be_valid_sse_event

        parsed = parse_sse_event(sse_event)
        expect(parsed[:event]).to eq("task_status_update")
        expect(parsed[:id]).to eq("ruby-event-1")
        expect(parsed[:data]).to be_valid_task_status_update_event
      end
    end
  end

  describe "Authentication Interoperability" do
    context "with Python SDK authentication" do
      it "handles OAuth2 tokens from Python SDK" do
        # OAuth2 token format as used by Python SDK
        python_oauth_token = create_jwt_token(
          payload: {
            iss: "https://auth.example.com",
            aud: "a2a-api",
            sub: "python-client",
            scope: "read write",
            exp: 1.hour.from_now.to_i
          }
        )

        # Should be parseable by Ruby implementation
        expect(python_oauth_token).to be_a(String)
        expect(python_oauth_token.split(".").length).to eq(3)
      end

      it "generates API keys compatible with Python SDK" do
        ruby_api_key = test_api_key

        # API key format should be consistent
        expect(ruby_api_key).to start_with("ak_test_")
        expect(ruby_api_key.length).to be > 20
      end
    end
  end

  describe "Transport Protocol Interoperability" do
    context "HTTP transport" do
      it "uses consistent HTTP headers" do
        expected_headers = {
          "Content-Type" => "application/json",
          "Accept" => "application/json",
          "User-Agent" => /a2a-ruby/
        }

        # Mock HTTP request to verify headers
        stub_request(:post, "https://example.com/a2a")
          .with(headers: expected_headers)
          .to_return(status: 200, body: { jsonrpc: "2.0", result: {}, id: 1 }.to_json)

        # This would be tested in actual HTTP client implementation
        expect(true).to be true # Placeholder for actual HTTP client test
      end

      it "handles HTTP status codes consistently" do
        status_mappings = {
          200 => :success,
          400 => :bad_request,
          401 => :unauthorized,
          403 => :forbidden,
          404 => :not_found,
          429 => :rate_limited,
          500 => :internal_error,
          503 => :service_unavailable
        }

        status_mappings.each do |code, expected|
          # Verify that Ruby implementation handles these consistently
          expect(code).to be_a(Integer)
          expect(expected).to be_a(Symbol)
        end
      end
    end

    context "gRPC transport" do
      it "uses consistent gRPC service definitions", :skip_if_no_grpc do
        # This would test gRPC compatibility if gRPC is available
        # For now, just verify the transport constant exists
        expect(A2A::Types::TRANSPORT_GRPC).to eq("GRPC")
      end
    end
  end

  describe "Cross-SDK Integration Tests" do
    context "end-to-end message flow" do
      it "handles complete request-response cycle" do
        # Simulate a message from Python SDK client to Ruby SDK server
        python_request = {
          "jsonrpc" => "2.0",
          "method" => "message/send",
          "params" => {
            "message" => {
              "messageId" => test_uuid,
              "role" => "user",
              "kind" => "message",
              "parts" => [
                { "kind" => "text", "text" => "Process this with Ruby" }
              ]
            }
          },
          "id" => 1
        }

        # Parse request (Ruby server receiving from Python client)
        parsed_request = A2A::Protocol::JsonRpc.parse_request(python_request.to_json)
        expect(parsed_request).to be_a(A2A::Protocol::Request)

        # Generate response (Ruby server responding to Python client)
        ruby_response = A2A::Protocol::JsonRpc.build_response(
          result: {
            "messageId" => test_uuid,
            "role" => "agent",
            "kind" => "message",
            "parts" => [
              { "kind" => "text", "text" => "Processed by Ruby SDK" }
            ]
          },
          id: parsed_request.id
        )

        expect(ruby_response).to be_valid_json_rpc_response
        expect(ruby_response[:result]).to be_valid_a2a_message
      end

      it "handles task lifecycle across SDKs" do
        # Task created by Python SDK
        python_task = {
          "id" => test_uuid,
          "contextId" => test_uuid,
          "kind" => "task",
          "status" => {
            "state" => "submitted",
            "updatedAt" => Time.now.utc.iso8601
          }
        }

        expect(python_task).to be_valid_a2a_task

        # Task updated by Ruby SDK
        ruby_updated_task = python_task.merge(
          "status" => {
            "state" => "completed",
            "result" => { "processed_by" => "ruby-sdk" },
            "updatedAt" => Time.now.utc.iso8601
          }
        )

        expect(ruby_updated_task).to be_valid_a2a_task
      end
    end
  end

  describe "Data Serialization Compatibility" do
    it "handles JSON serialization consistently" do
      test_data = {
        string: "test",
        number: 42,
        float: 3.14,
        boolean: true,
        null_value: nil,
        array: [1, 2, 3],
        nested_object: {
          key: "value",
          nested_array: %w[a b c]
        }
      }

      # Serialize and deserialize
      json_string = test_data.to_json
      parsed_data = JSON.parse(json_string, symbolize_names: true)

      expect(parsed_data[:string]).to eq("test")
      expect(parsed_data[:number]).to eq(42)
      expect(parsed_data[:float]).to eq(3.14)
      expect(parsed_data[:boolean]).to be true
      expect(parsed_data[:null_value]).to be_nil
      expect(parsed_data[:array]).to eq([1, 2, 3])
      expect(parsed_data[:nested_object][:key]).to eq("value")
    end

    it "handles Unicode and special characters" do
      unicode_data = {
        emoji: "🚀🤖",
        chinese: "你好世界",
        arabic: "مرحبا بالعالم",
        special_chars: "!@#$%^&*()_+-=[]{}|;':\",./<>?"
      }

      json_string = unicode_data.to_json
      parsed_data = JSON.parse(json_string, symbolize_names: true)

      expect(parsed_data[:emoji]).to eq("🚀🤖")
      expect(parsed_data[:chinese]).to eq("你好世界")
      expect(parsed_data[:arabic]).to eq("مرحبا بالعالم")
      expect(parsed_data[:special_chars]).to eq("!@#$%^&*()_+-=[]{}|;':\",./<>?")
    end
  end
end
